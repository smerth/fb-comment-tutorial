<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>React Tutorial</title>
    <!-- Not present in the tutorial. Just for basic styling. -->
    <link rel="stylesheet" href="css/base.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.0.1/react.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.0.1/react-dom.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.16/browser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>
  </head>
  <body>
    <!-- This is the div where your code is rendering -->
    <div id="content"></div>
    <!-- <script type="text/babel" src="scripts/example.js"></script> -->
    <script type="text/babel">
      // To get started with this tutorial running your own code, simply remove
      // the script tag loading scripts/example.js and start writing code here.

      // blob of test json data
      // var data = [
      //   {id: 1, author: "Salamandar Hubunt", text: "This is one comment"},
      //   {id: 2, author: "Abdul Alexeikov", text: "This is *another* comment"}
      // ];

      var CommentBox = React.createClass({
        // Wrap a jQuery AJAX call to fetch data in its own function so we can call it when we need it.
        // ToDo make this a service?

        loadCommentsFromServer: function() {
          $.ajax({
            url: this.props.url,
            dataType: 'json',
            cache: false,
            success: function(data) {
              this.setState({data: data});
            }.bind(this),
            error: function(xhr, status, err) {
              console.error(this.props.url, status, err.toString());
            }.bind(this)
          });
        },
        //When a user submits a comment, we will need to refresh the list of comments to include the new one. It makes sense to do all of this logic in CommentBox since CommentBox owns the state that represents the list of comments.
        // The key to dynamic updates is the call to this.setState(). We replace the old array of comments with the new one from the server and the UI automatically updates itself. Because of this reactivity, it is only a minor change to add live updates. We will use simple polling here but you could easily use WebSockets or other technologies.
        handleCommentSubmit: function(comment) {
          var comments = this.state.data;
          // Optimistically set an id on the new comment. It will be replaced by an
          // id generated by the server. In a production application you would likely
          // not use Date.now() for this and would have a more robust system in place.
          comment.id = Date.now();
          var newComments = comments.concat([comment]);
          this.setState({data: newComments});
          $.ajax({
            url: this.props.url,
            dataType: 'json',
            type: 'POST',
            data: comment,
            success: function(data) {
              this.setState({data: data});
            }.bind(this),
            error: function(xhr, status, err) {
              this.setState({data: comments});
              console.error(this.props.url, status, err.toString());
            }.bind(this)
          });
        },
        //getInitialState() executes exactly once during the lifecycle of the component and sets up the initial state of the component.
        getInitialState: function() {
          return {data: []};
        },
        // componentDidMount is a method called automatically by React after a component is rendered for the first time.
        componentDidMount: function() {
          this.loadCommentsFromServer();
          setInterval(this.loadCommentsFromServer, this.props.pollInterval);
        },
        // Notes: Render function
        // this.props.data loads the data from the properties of this component (the json test data above) into the template of this component
        // <CommentList data={this.props.data} />
        // this.state.data loads the data into the template based on the current state of the component
        // We need to pass data from the child component back up to its parent. We do this in our parent's render method by passing a new callback (handleCommentSubmit) into the child, binding it to the child's onCommentSubmit event. Whenever the event is triggered, the callback will be invoked:
        render: function() {
          return (
            <div className="commentBox">
              <h1>Comments</h1>
              <CommentForm onCommentSubmit={this.handleCommentSubmit} />
              <CommentList data={this.state.data} />
            </div>
          );
        }
      });


      var CommentList = React.createClass({
        render: function() {
          var commentNodes = this.props.data.map(function(comment) {
            return (
              <Comment author={comment.author} key={comment.id}>
                {comment.text}
              </Comment>
            );
          });
          return (
            <div className="commentList">
              {commentNodes}
            </div>
          );
        }
      });

      // Build the comment input form
      // we will be using this.state to save the user's input as it is entered. We define an initial state with two properties author and text and set them to be empty strings. In our <input> elements, we set the value prop to reflect the state of the component and attach onChange handlers to them.
        var CommentForm = React.createClass({
          getInitialState: function() {
            return {author: '', text: ''};
          },
          handleAuthorChange: function(e) {
            this.setState({author: e.target.value});
          },
          handleTextChange: function(e) {
            this.setState({text: e.target.value});
          },
          //When the user submits the form, we should clear it, submit a request to the server, and refresh the list of comments. To start, let's listen for the form's submit event and clear it.
          handleSubmit: function(e) {
            // Call preventDefault() on the event to prevent the browser's default action of submitting the form.
             e.preventDefault();
             var author = this.state.author.trim();
             var text = this.state.text.trim();
             if (!text || !author) {
               return;
             }
             // Now that CommentBox has made the callback available to CommentForm via the onCommentSubmit prop, the CommentForm can call the callback when the user submits the form:
             this.props.onCommentSubmit({author: author, text: text});
             this.setState({author: '', text: ''});
           },
          // React attaches event handlers to components using a camelCase naming convention. We attach onChange handlers to the two <input> elements. Now, as the user enters text into the <input> fields, the attached onChange callbacks are fired and the state of the component is modified. Subsequently, the rendered value of the input element will be updated to reflect the current component state.
          render: function() {
            return (
              //We attach an onSubmit handler to the form that clears the form fields when the form is submitted with valid input.
              <form className="commentForm" onSubmit={this.handleSubmit}>
              <input
                type="text"
                placeholder="Your name"
                value={this.state.author}
                onChange={this.handleAuthorChange}
              />
              <input
                type="text"
                placeholder="Say something..."
                value={this.state.text}
                onChange={this.handleTextChange}
              />
              <input type="submit" value="Post" />
              </form>
            );
          }
        });

      var Comment = React.createClass({
        // This makes Markup comonent responsible for cleaning html instead of React. Then you have to call the function on the
        rawMarkup: function() {
          var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
          return { __html: rawMarkup };
        },

        render: function() {
          return (
            <div className="comment">
              <h2 className="commentAuthor">
                {this.props.author}
              </h2>
              <span dangerouslySetInnerHTML={this.rawMarkup()} />
            </div>
          );
        }
      });


      // Here the CommentBox is rendered and the two parameters (properties?) are set.  The url for the data call and the pollInterval to call again
      ReactDOM.render(
        <CommentBox url="/api/comments" pollInterval={2000} />,
        document.getElementById('content')
      );
    </script>
  </body>
</html>
